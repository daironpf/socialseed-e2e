# üìò Gu√≠a para Agentes de IA - SocialSeed E2E Framework

> **Versi√≥n 2.0 - Actualizado para evitar errores comunes**

Esta gu√≠a te permite generar tests E2E funcionales sin errores de importaci√≥n, serializaci√≥n o configuraci√≥n.

---

## üö® REGLAS DE ORO (Lee esto primero)

### 1. **Imports SIEMPRE Absolutos**
```python
# ‚ùå NUNCA uses imports relativos
from ..data_schema import RegisterRequest  # PROHIBIDO

# ‚úÖ SIEMPRE uses imports absolutos
from services.auth_service.data_schema import RegisterRequest
from services.auth_service.auth_page import AuthServicePage
```

### 2. **Serializaci√≥n con Aliases**
```python
# ‚ùå NUNCA sin by_alias=True (env√≠a refresh_token en lugar de refreshToken)
data = request.model_dump()

# ‚úÖ SIEMPRE con by_alias=True (env√≠a refreshToken como espera Java)
data = request.model_dump(by_alias=True)
```

### 3. **Modelos Pydantic con Config**
```python
class RefreshTokenRequest(BaseModel):
    # SIEMPRE incluye esto
    model_config = {"populate_by_name": True}

    # Campos compuestos SIEMPRE con alias camelCase
    refresh_token: str = Field(
        ...,
        alias="refreshToken",
        serialization_alias="refreshToken"
    )
```

### 4. **Manejo Manual de Headers**
```python
# ‚ùå NO existe update_headers()
self.update_headers({"Authorization": f"Bearer {token}"})

# ‚úÖ Implementa _get_headers() manualmente
def _get_headers(self, extra=None):
    headers = {"Content-Type": "application/json"}
    if self.access_token:
        headers["Authorization"] = f"Bearer {self.access_token}"
    return headers
```

### 5. **Nombres de M√©todos sin Conflicto**
```python
# ‚ùå Conflicto: atributo refresh_token vs m√©todo refresh_token()
self.refresh_token = token  # Atributo

# ‚úÖ Usa prefijo do_ para m√©todos
self.refresh_token = token  # Atributo
self.do_refresh_token()      # M√©todo
```

---

## üì¶ Dependencias Requeridas

El archivo `requirements.txt` debe incluir:

```
pydantic>=2.0.0
email-validator>=2.0.0  # REQUERIDO para EmailStr
dnspython>=2.0.0          # Para validaci√≥n de email
```

**Si falta email-validator:**
```
ImportError: email-validator is not installed
```

**Soluci√≥n:**
```bash
pip install -r requirements.txt
```

---

## üéØ Templates Actualizados

### data_schema.py - Estructura Base

```python
"""Data schema for <service> API.

‚ö†Ô∏è IMPORTANTE: Todos los campos compuestos usan camelCase aliases.
"""
from pydantic import BaseModel, Field, EmailStr
from typing import Optional


class LoginRequest(BaseModel):
    """Login request."""
    model_config = {"populate_by_name": True}

    email: EmailStr
    password: str


class RefreshTokenRequest(BaseModel):
    """Refresh token request."""
    model_config = {"populate_by_name": True}

    # ‚ö†Ô∏è camelCase alias requerido para backend Java
    refresh_token: str = Field(
        ...,
        alias="refreshToken",
        serialization_alias="refreshToken"
    )
```

### service_page.py - Estructura Base

```python
"""Page object for <service> API."""
from typing import Optional, Dict, Any
from playwright.sync_api import APIResponse
from socialseed_e2e.core.base_page import BasePage

from .data_schema import (
    ENDPOINTS,
    LoginRequest,
    RefreshTokenRequest,
)


class AuthPage(BasePage):
    """Page for auth service."""

    def __init__(self, base_url: str, **kwargs):
        super().__init__(base_url=base_url, **kwargs)
        self.access_token: Optional[str] = None
        self.refresh_token: Optional[str] = None

    def _get_headers(self, extra: Optional[Dict] = None) -> Dict[str, str]:
        headers = {"Content-Type": "application/json"}
        if self.access_token:
            headers["Authorization"] = f"Bearer {self.access_token}"
        if extra:
            headers.update(extra)
        return headers

    def do_login(self, request: LoginRequest) -> APIResponse:
        """Login and store tokens."""
        response = self.post(
            ENDPOINTS["login"],
            data=request.model_dump(by_alias=True)  # ‚úÖ SIEMPRE by_alias=True
        )
        if response.ok:
            data = response.json()["data"]
            self.access_token = data.get("token")
            self.refresh_token = data.get("refreshToken")
        return response

    def do_refresh_token(self) -> APIResponse:
        """Refresh access token."""
        if not self.refresh_token:
            raise ValueError("No refresh token")

        request = RefreshTokenRequest(refresh_token=self.refresh_token)
        response = self.post(
            ENDPOINTS["refresh"],
            data=request.model_dump(by_alias=True)  # ‚úÖ SIEMPRE by_alias=True
        )
        if response.ok:
            data = response.json()["data"]
            self.access_token = data.get("token")
            self.refresh_token = data.get("refreshToken")
        return response
```

### modules/01_login_flow.py - Estructura Base

```python
"""Test module 01: Login flow."""
from services.auth_service.data_schema import LoginRequest, TEST_USER

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from services.auth_service.auth_page import AuthPage


def run(page: "AuthPage"):
    """Execute login test."""
    print("STEP 01: Testing Login")

    login_data = LoginRequest(
        email=TEST_USER["email"],
        password=TEST_USER["password"]
    )

    response = page.do_login(login_data)

    assert response.ok, f"Login failed: {response.status}"
    assert page.access_token is not None, "Token not stored"

    print(f"‚úì Login successful")
    print(f"‚úì Token: {page.access_token[:20]}...")
```

---

## üîß Soluci√≥n de Problemas

### Problema 1: `ImportError: email-validator is not installed`

**Causa:** Falta la dependencia email-validator.

**Soluci√≥n:**
1. Aseg√∫rate de que `requirements.txt` incluya `email-validator>=2.0.0`
2. Ejecuta: `pip install -r requirements.txt`

### Problema 2: `cannot import name '_01_register_flow'`

**Causa:** Los m√≥dulos con nombres num√©ricos no pueden importarse normalmente.

**Soluci√≥n - Tres m√©todos:**

**M√©todo A: importlib (recomendado para scripts)**
```python
import importlib.util
import importlib.machinery

def load_module(name, path):
    loader = importlib.machinery.SourceFileLoader(name, path)
    spec = importlib.util.spec_from_loader(name, loader)
    module = importlib.util.module_from_spec(spec)
    loader.exec_module(module)
    return module

register_module = load_module(
    "register_flow",
    "/path/to/services/auth/modules/01_register_flow.py"
)
register_module.run(page)
```

**M√©todo B: Import directo**
```python
from services.auth.modules._01_register_flow import run
run(page)
```

**M√©todo C: Import funci√≥n**
```python
from services.auth.modules import _01_register_flow
_01_register_flow.run(page)
```

### Problema 3: `Refresh token is required` (400 error)

**Causa:** Pydantic serializa `refresh_token` en lugar de `refreshToken`.

**Soluci√≥n:**
1. En el modelo, usa alias camelCase:
```python
refresh_token: str = Field(
    ...,
    alias="refreshToken",
    serialization_alias="refreshToken"
)
```

2. Al serializar, usa by_alias=True:
```python
data = request.model_dump(by_alias=True)
```

### Problema 4: `Method declaration "logout" is obscured`

**Causa:** Conflicto entre atributo y m√©todo con mismo nombre.

**Soluci√≥n:**
```python
# Atributo
self.refresh_token: Optional[str] = None

# M√©todo con prefijo do_
def do_refresh_token(self):
    pass

def do_logout(self):
    pass
```

### Problema 5: `update_headers not found`

**Causa:** El m√©todo `update_headers()` no existe en `BasePage`.

**Soluci√≥n:** Implementa manejo manual:
```python
def _get_headers(self, extra=None):
    headers = {"Content-Type": "application/json"}
    if self.access_token:
        headers["Authorization"] = f"Bearer {self.access_token}"
    if extra:
        headers.update(extra)
    return headers
```

---

## ‚úÖ Checklist Pre-Entrega

Antes de decir "terminado", verifica:

- [ ] `email-validator` est√° en requirements.txt
- [ ] Todos los modelos tienen `model_config = {"populate_by_name": True}`
- [ ] Campos compuestos tienen `alias` y `serialization_alias` en camelCase
- [ ] En todos los m√©todos de page: `request.model_dump(by_alias=True)`
- [ ] NING√öN import relativo (`from ..x`)
- [ ] Todos los imports son absolutos (`from services.xxx`)
- [ ] M√©todos conflictivos usan prefijo `do_` (do_refresh_token, do_logout)
- [ ] Headers manejados manualmente (no update_headers)
- [ ] Funciones `run(page)` bien definidas en m√≥dulos
- [ ] Type hints usando `TYPE_CHECKING` para evitar imports circulares

---

## üéØ Flujo de Trabajo Recomendado

### Para Agentes de IA:

1. **Lee los controladores Java** del servicio target
2. **Identifica endpoints**: rutas, m√©todos HTTP, body params
3. **Crea data_schema.py**:
   - Modelos Pydantic con aliases camelCase
   - Constantes de endpoints
   - Datos de test
4. **Crea service_page.py**:
   - Hereda de BasePage
   - Implementa _get_headers()
   - M√©todos para cada endpoint
   - Usa by_alias=True siempre
5. **Crea modules/**:
   - 01_*_flow.py: Crear/Login
   - 02_*_flow.py: Operaciones CRUD
   - 99_*_flow.py: Cleanup/Logout
6. **Verifica** ejecutando: `python verify_installation.py`

---

## üìö Recursos Adicionales

- **Ejemplo Completo:** Ver `.agent/EXAMPLE_TEST.md`
- **Flujo de Generaci√≥n:** Ver `.agent/WORKFLOW_GENERATION.md`
- **Documentaci√≥n Framework:** https://daironpf.github.io/socialseed-e2e/
- **Pydantic v2:** https://docs.pydantic.dev/latest/

---

## üéì Tips para √âxito

1. **Siempre verifica serializaci√≥n:**
   ```python
   print(request.model_dump(by_alias=True))
   # Debe mostrar camelCase: {'refreshToken': 'xxx'}
   # NO snake_case: {'refresh_token': 'xxx'}
   ```

2. **Test incremental:**
   - Ejecuta test 01 primero
   - Verifica que el estado se guarda en `page`
   - Luego ejecuta test 02

3. **Manejo de errores:**
   ```python
   assert response.ok, f"Failed: {response.status} - {response.text()[:100]}"
   ```

4. **Compartir estado:**
   - Guarda en `page` (ej: `page.user_id = data["id"]`)
   - Recupera en siguiente test

5. **Ejecuci√≥n Flexible:**
   Si ejecutas desde el root del proyecto y el config est√° en una subcarpeta:
   ```bash
   e2e run -c otrotest/e2e.conf
   ```
   El framework encontrar√° los servicios autom√°ticamente.

---

## üöÄ Resultado Esperado

Siguiendo esta gu√≠a, los agentes de IA pueden generar:

- ‚úÖ Tests funcionales sin errores de importaci√≥n
- ‚úÖ Serializaci√≥n correcta camelCase ‚Üî snake_case
- ‚úÖ Manejo de autenticaci√≥n entre tests
- ‚úÖ Tests secuenciales con estado compartido

**Tiempo estimado:** 2-5 minutos por servicio
**Intervenci√≥n humana:** M√≠nima o ninguna

---

**Versi√≥n:** 2.0
**√öltima actualizaci√≥n:** 2026-02-03
**Framework:** socialseed-e2e v0.1.0+
